package com.virtualprodigyllc.sampler;

public class AnimatedListView extends ListView{

	import android.content.Context;
	import android.graphics.Bitmap;
	import android.graphics.Camera;
	import android.graphics.Canvas;
	import android.graphics.Color;
	import android.graphics.LightingColorFilter;
	import android.graphics.Matrix;
	import android.graphics.Paint;
	import android.util.AttributeSet;
	import android.util.Log;
	import android.view.View;
	import android.widget.ListView;


	    private Camera mCamera = new Camera();
	    private Matrix mMatrix = new Matrix();
		
		public ListViewWheelOfFortuneStyle(Context context) {
			super(context);
			// TODO Auto-generated constructor stub
		}

		public ListViewWheelOfFortuneStyle(Context context, AttributeSet attrs) {
			super(context, attrs);
			// TODO Auto-generated constructor stub
		}
		
		public ListViewWheelOfFortuneStyle(Context context, AttributeSet attrs,
				int defStyle) {
			super(context, attrs, defStyle);
			// TODO Auto-generated constructor stub
		}

		@Override
	    protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
//			if(child.getId() == R.layout.empty_top_memoirs_view){
//				Log.d("Tweeking the 3d list view", "dont fancness for an empty list");
//				return super.drawChild(canvas, child, drawingTime);
//				 
//			}
	        // get top left coordinates
//			setDrawingCacheEnabled(true);
//			buildDrawingCache();
			Bitmap bitmap = child.getDrawingCache();
			if(bitmap == null){//I keep getting nulls for some reason
//				setDrawingCacheEnabled(true);// the nulls are problly because i need a drawing cache on the children not the parent.
//				buildDrawingCache();
				child.setDrawingCacheEnabled(true); // and now i have doubles drawing wtf and the wheel affect is sideways wtf did i do...
				child.buildDrawingCache();
				bitmap = child.getDrawingCache();
			}
	        int left = child.getLeft();
	        int top = child.getTop();

	        // get offset to center
	        int centerX = child.getWidth() / 2;
	        int centerY = child.getHeight() / 2;

	        // get absolute center of child
	        float pivotX = left + centerX;
	        float pivotY = top + centerY;

	        // calculate distance from center
	        float centerScreen = getHeight() / 2;
	        float distFromCenter = (pivotY - centerScreen) / centerScreen;

	        // calculate scale and rotation
	        float scale = (float)(1 - 2 * (1 - Math.cos(distFromCenter)));
	        if(scale < 0.5f)
	        	scale = 0.5f; //i dont want them too small
	        if(child == getChildAt(0));
	        	Log.d("Tweeking the 3d list view", "scale is" + scale);//use this to set a minimum scale down
	        float rotation =distFromCenter;

	        canvas.save();
//	        canvas.rotate(rotation, pivotX, pivotY);// i want caleing via the camera not a rotation
	        canvas.scale(scale, scale, pivotX, pivotY);
//	        Bitmap bitmap = child.getDrawingCache();
	        Paint paint = new Paint();
	        paint.setAntiAlias(true);
	        paint.setFilterBitmap(true);
	        
	        
	        if (mCamera == null) {
	            mCamera = new Camera();
	        }
	        mCamera.save();
	        mCamera.rotateY(rotation);

	        if (mMatrix == null) {
	            mMatrix = new Matrix();
	        }
	        mCamera.getMatrix(mMatrix);
	        mCamera.restore();

	        paint.setColorFilter(phongIllumination((float)rotation * 15));
	        mMatrix.preTranslate(-centerX, -centerY);
	        mMatrix.postScale(scale, scale);
//	        mMatrix.postScale(centerX, centerY);
	        mMatrix.postTranslate(pivotX, pivotY);
//	        mMatrix.postTranslate(left, top);

//	        Bitmap bitmap = child.getDrawingCache();
//	        canvas.drawBitmap(bitmap, mMatrix, paint);
	        canvas.drawBitmap(bitmap, left, top, paint);
//	        super.drawChild(canvas, child, drawingTime);

	        canvas.restore();
	        return false;
	    }

		//the shadowly figure level
		private static final int AMBIENT_LIGHT = 55;
		//the light and shadows based on camera lighting
		private static final int DIFFUSE_LIGHT = 200;
		//the brightness of shine points
		private static final float SPECULAR_LIGHT = 70;
		//over all shine level
		private static final float SHININESS = 200;
		//the brightest this can be, so the equation doesnt over brighten
		private static final int MAX_INTENSITY = 0xFF;
		//ambient + diffuse + specular = phong reflection see wiki page	

	private LightingColorFilter  phongIllumination(final float rotation) {
			final double cosRotation = Math.cos(Math.PI * rotation / 180);
			int intensity = AMBIENT_LIGHT + (int) (DIFFUSE_LIGHT * cosRotation);
			int highlightIntensity = (int) (SPECULAR_LIGHT * Math.pow(cosRotation, SHININESS));
			if (intensity > MAX_INTENSITY) {
				intensity = MAX_INTENSITY;
			}
			if (highlightIntensity > MAX_INTENSITY) {
				highlightIntensity = MAX_INTENSITY;
			}
			final int light = Color.rgb(intensity, intensity, intensity);
			final int highlight = Color.rgb(highlightIntensity, highlightIntensity, highlightIntensity);
			return new LightingColorFilter(light, highlight);
		}
	}


